import { parse } from "encoding/yaml.ts";
import { schemaToType } from "./interface.ts";
import { toCapitalizationCase } from "../lib/text.ts";
import { capitalize } from "../text.ts";
import { join } from "path/mod.ts";

export async function generateTypesFromSchemas(resourcePath: string) {
  const definitionsSchema = parse(
    Deno.readTextFileSync(join(resourcePath, "/schema/definitions.yml")),
    // deno-lint-ignore no-explicit-any
  ) as any;
  const projectSchema = parse(
    Deno.readTextFileSync(join(resourcePath, "/schema/project.yml")),
    // deno-lint-ignore no-explicit-any
  ) as any;

  // deno-lint-ignore no-explicit-any
  const schemas: { name: string; schema: any }[] = [];

  for (const definition of definitionsSchema) {
    schemas.push({
      name: capitalize(toCapitalizationCase(definition.id)),
      schema: definition,
    });
  }

  schemas.push(
    {
      name: "ProjectConfig",
      schema: projectSchema[0],
    },
    {
      name: "BookProject",
      schema: projectSchema[2],
    },
  );

  const autoGeneratedTypes: string[] = [
    "// This file is automatically generated by `quarto build-js`! Do not edit.",
    "export type MaybeArrayOf<T> = (T | T[]);",
    "export type SchemaObject = { [key: string]: string };",
  ];

  for (const { name, schema } of schemas) {
    try {
      autoGeneratedTypes.push(`export type ${name} = ${schemaToType(schema)}`);
    } catch (e) {
      console.error(JSON.stringify(schema, null, 2));
      throw e;
    }
  }

  Deno.mkdirSync(join(resourcePath, "/types"), { recursive: true });
  Deno.writeTextFileSync(
    join(resourcePath, "/types/schema-types.ts"),
    autoGeneratedTypes.join("\n\n"),
  );

  await Deno.run({
    cmd: [Deno.execPath(), "fmt", join(resourcePath, "/types/schema-types.ts")],
  }).status();
}
